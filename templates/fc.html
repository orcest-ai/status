<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{ view_data.title }}</title>
  <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.6.0/dist/panzoom.min.js"></script>
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'dark', securityLevel: 'loose' });
  </script>
  <style>
    :root { --bg:#0a0a0f; --panel:#111827; --line:#1f2937; --txt:#e2e8f0; --muted:#94a3b8; --link:#60a5fa; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    body { margin: 0; background: var(--bg); color: var(--txt); font-family: Inter, system-ui, sans-serif; }
    .wrap { max-width: 1380px; margin: 0 auto; padding: 24px; }
    .toolbar, .views { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 12px; }
    .toolbar button, .toolbar a, .views a {
      border: 1px solid #334155; background: var(--panel); color: var(--txt);
      border-radius: 8px; padding: 8px 12px; text-decoration: none; cursor: pointer;
    }
    .toolbar button:hover, .toolbar a:hover, .views a:hover { border-color: var(--link); color: var(--link); }
    .views a.active { border-color: var(--link); color: var(--link); }
    .card { background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 12px; }
    #diagramHost { min-height: 460px; border: 1px dashed #334155; border-radius: 10px; overflow: hidden; display: flex; align-items: center; justify-content: center; }
    #diagramHost svg { touch-action: none; cursor: grab; width: 100%; height: auto; }
    .mermaid { display: none; }
    .grid { margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .panel { background: #0f172a; border: 1px solid #1e293b; border-radius: 10px; padding: 12px; }
    pre { margin: 0; white-space: pre-wrap; word-break: break-word; color: #cbd5e1; font-size: 12px; }
    .hint { margin-top: 10px; color: var(--muted); font-size: 13px; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; color: var(--muted); font-size: 12px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; }
    .ok { background: var(--ok); } .warn { background: var(--warn); } .bad { background: var(--bad); }
    .drawer {
      position: fixed; top: 0; right: -420px; width: 420px; max-width: calc(100vw - 20px);
      height: 100vh; background: #0b1220; border-left: 1px solid #1e293b; transition: right .2s ease;
      z-index: 50; padding: 16px; box-sizing: border-box; overflow-y: auto;
    }
    .drawer.open { right: 0; }
    .drawerHead { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
    .drawerTitle { font-size: 15px; font-weight: 600; }
    .muted { color: var(--muted); font-size: 12px; }
    .kv { display: grid; grid-template-columns: 120px 1fr; gap: 6px 8px; margin: 8px 0; font-size: 13px; }
    .kv .k { color: var(--muted); }
    .badge { display:inline-block; padding:3px 8px; border:1px solid #334155; border-radius:999px; font-size:12px; }
    .drawer button, .drawer a {
      border: 1px solid #334155; background: #111827; color: var(--txt); border-radius: 8px;
      padding: 7px 10px; text-decoration: none; cursor: pointer; font-size: 12px;
    }
    .drawerActions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    #sparkline { width: 100%; height: 90px; border: 1px solid #1e293b; border-radius: 8px; background: #020617; }
    .flow-edge path {
      stroke-dasharray: 10 8;
      animation: flowDash 1.6s linear infinite;
      stroke-width: 2.2px;
      stroke: #60a5fa;
      opacity: 0.9;
    }
    .replayItem {
      border: 1px solid #1e293b; border-radius: 8px; padding: 8px; margin-bottom: 8px;
      cursor: pointer; background: #020617;
    }
    .replayItem:hover { border-color: #60a5fa; }
    .replayItem.active { border-color: #22c55e; box-shadow: inset 0 0 0 1px #22c55e; }
    @keyframes flowDash { to { stroke-dashoffset: -36; } }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>{{ view_data.title }}</h1>
    <p style="color:#94a3b8;">{{ view_data.subtitle }}</p>
    {% if error_message %}
    <p style="color:#f59e0b;">{{ error_message }}</p>
    {% endif %}

    <div class="views">
      {% for view in views %}
      <a href="/fc/{{ view.key }}" class="{% if view.key == current_view %}active{% endif %}">{{ view.title }}</a>
      {% endfor %}
    </div>

    <div class="toolbar">
      <a href="/">Dashboard</a>
      <a href="/api/status?force=true" target="_blank">Open Status JSON</a>
      <a href="/api/topology/{{ current_view }}" target="_blank">Open View API</a>
      <button id="zoomInBtn" type="button">Zoom In</button>
      <button id="zoomOutBtn" type="button">Zoom Out</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="exportSvgBtn" type="button">Export SVG</button>
      <button id="exportPngBtn" type="button">Export PNG</button>
      <button id="impactModeBtn" type="button">Impact Mode: OFF</button>
      <button id="autoReplayBtn" type="button">Auto Replay: ON</button>
    </div>

    <div class="card">
      <div id="diagramHost"></div>
      <pre class="mermaid">{{ view_data.mermaid }}</pre>
      <div class="hint">Tip: click a linked node to drill down into that component topology.</div>
      <div class="legend">
        <span><span class="dot ok"></span>Operational</span>
        <span><span class="dot warn"></span>Degraded</span>
        <span><span class="dot bad"></span>Down/Timeout</span>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <strong>Realtime Snapshot</strong>
        <pre id="snapshot">Loading...</pre>
      </div>
      <div class="panel">
        <strong>Linked Nodes in This View</strong>
        <pre id="nodeLinksPanel">Loading...</pre>
      </div>
      <div class="panel">
        <strong>Recent Request Path Replay</strong>
        <pre id="flowSummary">Loading...</pre>
        <div id="replayList" style="margin-top:8px; max-height: 220px; overflow:auto;"></div>
      </div>
      <div class="panel">
        <strong>Impact Analyzer</strong>
        <pre id="impactPanel">Loading...</pre>
      </div>
    </div>
  </div>

  <aside id="nodeDrawer" class="drawer" aria-hidden="true">
    <div class="drawerHead">
      <div>
        <div id="drawerTitle" class="drawerTitle">Node details</div>
        <div id="drawerSub" class="muted">Select a node in the graph</div>
      </div>
      <button id="closeDrawerBtn" type="button">Close</button>
    </div>
    <div id="drawerBody">
      <div class="muted">No node selected.</div>
    </div>
  </aside>

  <script>
    const topology = {{ view_data | tojson }};
    const currentView = {{ current_view | tojson }};
    let latestStatus = null;
    let activeNodeContext = null;
    let impactMode = false;
    let autoReplay = true;
    let lastImpact = null;
    let replayData = [];
    let selectedReplayEventId = null;
    let replayIdx = 0;

    function normalizeLabel(v) {
      return String(v || '').replace(/\s+/g, ' ').trim();
    }

    function downloadFile(filename, content, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function setupPanZoomAndExports(svg) {
      const host = document.getElementById('diagramHost');
      if (!svg || !host || !window.Panzoom) return null;
      host.innerHTML = '';
      host.appendChild(svg);
      const panzoom = window.Panzoom(svg, { maxScale: 3.5, minScale: 0.4, step: 0.2 });
      host.addEventListener('wheel', panzoom.zoomWithWheel, { passive: false });

      document.getElementById('zoomInBtn').addEventListener('click', () => panzoom.zoomIn());
      document.getElementById('zoomOutBtn').addEventListener('click', () => panzoom.zoomOut());
      document.getElementById('resetBtn').addEventListener('click', () => panzoom.reset());

      document.getElementById('exportSvgBtn').addEventListener('click', () => {
        const svgRaw = new XMLSerializer().serializeToString(svg);
        downloadFile(`status-topology-${currentView}.svg`, svgRaw, 'image/svg+xml;charset=utf-8');
      });

      document.getElementById('exportPngBtn').addEventListener('click', () => {
        const svgRaw = new XMLSerializer().serializeToString(svg);
        const image64 = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgRaw)));
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width || 1600;
          canvas.height = img.height || 900;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#0a0a0f';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          const a = document.createElement('a');
          a.href = canvas.toDataURL('image/png');
          a.download = `status-topology-${currentView}.png`;
          a.click();
        };
        img.src = image64;
      });
      return panzoom;
    }

    function findNodeShape(nodeGroup) {
      return nodeGroup.querySelector('rect, polygon, path, ellipse');
    }

    function nodeLabel(nodeGroup) {
      return normalizeLabel(nodeGroup.textContent);
    }

    function colorForStatus(status) {
      if (status === 'operational') return { fill: '#0b3a21', stroke: '#22c55e' };
      if (status === 'degraded') return { fill: '#3a2a08', stroke: '#f59e0b' };
      if (status === 'down' || status === 'timeout' || status === 'partial_outage') return { fill: '#3f1212', stroke: '#ef4444' };
      return { fill: '#1f2937', stroke: '#334155' };
    }

    function impactColor(score) {
      if (score >= 0.85) return { fill: '#521515', stroke: '#ef4444' };
      if (score >= 0.55) return { fill: '#4a2e0e', stroke: '#f59e0b' };
      if (score > 0.2) return { fill: '#1f3658', stroke: '#60a5fa' };
      return null;
    }

    function formatMs(v) {
      if (v == null) return '-';
      return `${Number(v).toFixed(2)} ms`;
    }

    function statusBadge(status) {
      const c = colorForStatus(status || 'unknown');
      return `<span class="badge" style="border-color:${c.stroke}; color:${c.stroke};">${status || 'unknown'}</span>`;
    }

    function findServiceNameByLabel(label) {
      const serviceMap = topology.service_map || {};
      const entry = Object.entries(serviceMap).find(([k]) => normalizeLabel(label).includes(normalizeLabel(k)));
      return entry ? entry[1] : null;
    }

    function nodeCenter(nodeGroup) {
      const box = nodeGroup.getBBox();
      return { x: box.x + box.width / 2, y: box.y + box.height / 2 };
    }

    function findNodeByAlias(svg, alias) {
      const key = normalizeLabel(alias).toLowerCase();
      const nodes = [...svg.querySelectorAll('g.node')];
      return nodes.find((n) => nodeLabel(n).toLowerCase().includes(key)) || null;
    }

    function ensureReplayLayer(svg) {
      let layer = svg.querySelector('#replay-overlay-layer');
      if (!layer) {
        layer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        layer.setAttribute('id', 'replay-overlay-layer');
        layer.setAttribute('style', 'pointer-events:none;');
        svg.appendChild(layer);
      }
      layer.innerHTML = '';
      return layer;
    }

    function drawReplayPath(svg, evt) {
      if (!svg || !evt || !evt.nodes || evt.nodes.length < 2) return;
      const layer = ensureReplayLayer(svg);
      const qps = Number(evt.qps || 1.0);
      const latency = Number(evt.latency_ms || 600.0);
      const width = Math.max(2, Math.min(9, 1.5 + (qps / 1.8)));
      const duration = Math.max(0.8, Math.min(3.2, latency / 520.0));
      for (let i = 0; i < evt.nodes.length - 1; i += 1) {
        const a = findNodeByAlias(svg, evt.nodes[i]);
        const b = findNodeByAlias(svg, evt.nodes[i + 1]);
        if (!a || !b) continue;
        const p1 = nodeCenter(a);
        const p2 = nodeCenter(b);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', String(p1.x));
        line.setAttribute('y1', String(p1.y));
        line.setAttribute('x2', String(p2.x));
        line.setAttribute('y2', String(p2.y));
        line.setAttribute('stroke', evt.status === 'degraded' ? '#f59e0b' : '#38bdf8');
        line.setAttribute('stroke-width', String(width));
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('opacity', '0.9');
        line.setAttribute('stroke-dasharray', '12 9');
        line.style.animation = `flowDash ${duration}s linear infinite`;
        layer.appendChild(line);
      }
    }

    function applyNodeLinks(svg) {
      const links = topology.node_links || {};
      document.getElementById('nodeLinksPanel').textContent = JSON.stringify(links, null, 2);
      const linkEntries = Object.entries(links).map(([k, v]) => [normalizeLabel(k), v]);
      svg.querySelectorAll('g.node').forEach((node) => {
        const label = nodeLabel(node);
        const matched = linkEntries.find(([k]) => label.includes(k));
        const target = matched ? matched[1] : null;
        node.style.cursor = 'pointer';
        node.addEventListener('click', () => openNodeDrawer({ label, target }));
        node.addEventListener('dblclick', () => {
          if (!target) return;
          if (target.startsWith('/')) window.location.href = target;
          else window.open(target, '_blank', 'noopener');
        });
      });
    }

    function applyRealtimeNodeStatus(svg, statusData) {
      const serviceMap = topology.service_map || {};
      const byName = {};
      (statusData.services || []).forEach((s) => { byName[s.name] = s; });

      svg.querySelectorAll('g.node').forEach((node) => {
        const label = nodeLabel(node);
        const mapped = Object.entries(serviceMap).find(([k]) => label.includes(normalizeLabel(k)));
        if (!mapped) return;
        const svcName = mapped[1];
        const svcData = byName[svcName];
        if (!svcData) return;
        const shape = findNodeShape(node);
        if (!shape) return;
        const color = colorForStatus(svcData.status);
        shape.style.fill = color.fill;
        shape.style.stroke = color.stroke;
        shape.style.strokeWidth = '2px';
        node.dataset.serviceName = svcName;
      });
    }

    function applyImpactHeatmap(svg) {
      if (!impactMode || !lastImpact) return;
      const impactScores = lastImpact.impact_scores || {};
      svg.querySelectorAll('g.node').forEach((node) => {
        const label = nodeLabel(node);
        const service = findServiceNameByLabel(label);
        if (!service) return;
        const score = Number(impactScores[service] || 0);
        if (score <= 0) return;
        const heat = impactColor(score);
        if (!heat) return;
        const shape = findNodeShape(node);
        if (!shape) return;
        shape.style.fill = heat.fill;
        shape.style.stroke = heat.stroke;
        shape.style.strokeWidth = '2.5px';
      });
    }

    function applyFlowAnimation(svg) {
      if (!svg) return;
      const paths = svg.querySelectorAll('g.edgePath path.path');
      let avgQps = 1.0;
      let avgLatency = 700.0;
      if (replayData.length) {
        avgQps = replayData.reduce((a, x) => a + Number(x.qps || 0), 0) / replayData.length;
        avgLatency = replayData.reduce((a, x) => a + Number(x.latency_ms || 0), 0) / replayData.length;
      }
      const width = Math.max(1.5, Math.min(5, 1.2 + (avgQps / 4.0)));
      const duration = Math.max(1.0, Math.min(3.5, avgLatency / 380.0));
      paths.forEach((p, idx) => {
        const parent = p.closest('g.edgePath');
        if (!parent) return;
        parent.classList.add('flow-edge');
        p.style.strokeWidth = `${width}px`;
        p.style.animationDuration = `${duration}s`;
        p.style.animationDelay = `${(idx % 8) * 0.08}s`;
      });
    }

    async function fetchNodeDetail(serviceName) {
      const url = `/api/status/node/${encodeURIComponent(serviceName)}?limit=60`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Node detail failed (${r.status})`);
      return r.json();
    }

    function renderMultiMetricTimeline(points) {
      if (!points.length) return '<div class="muted">No timeline samples yet.</div>';
      const w = 360;
      const h = 130;
      const lat = points.map((p) => Number(p.latency_ms || 0));
      const err = [];
      const tran = [];
      for (let i = 0; i < points.length; i += 1) {
        const window = points.slice(Math.max(0, i - 9), i + 1);
        const failCount = window.filter((x) => Number(x.code || 0) >= 400 || ['degraded', 'down', 'timeout', 'partial_outage'].includes(String(x.status))).length;
        err.push((failCount / window.length) * 100);
        const prev = i > 0 ? points[i - 1].status : points[i].status;
        tran.push(points[i].status !== prev ? 100 : 0);
      }
      const mkPolyline = (values, color, maxV) => {
        const step = values.length > 1 ? (w - 12) / (values.length - 1) : 0;
        const coords = values.map((v, i) => {
          const x = 6 + i * step;
          const y = h - 8 - ((v / Math.max(maxV, 1)) * (h - 16));
          return `${x.toFixed(1)},${y.toFixed(1)}`;
        }).join(' ');
        return `<polyline fill="none" stroke="${color}" stroke-width="2" points="${coords}"></polyline>`;
      };
      return `
        <svg id="sparkline" viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
          <polyline fill="none" stroke="#334155" stroke-width="1" points="6,${h - 8} ${w - 6},${h - 8}"></polyline>
          ${mkPolyline(lat, '#60a5fa', Math.max(...lat, 1))}
          ${mkPolyline(err, '#ef4444', 100)}
          ${mkPolyline(tran, '#f59e0b', 100)}
        </svg>
        <div class="muted" style="margin-top:6px;">blue=latency, red=error rate window, amber=status transition spikes</div>
      `;
    }

    function closeNodeDrawer() {
      const drawer = document.getElementById('nodeDrawer');
      drawer.classList.remove('open');
      drawer.setAttribute('aria-hidden', 'true');
      activeNodeContext = null;
    }

    async function openNodeDrawer(ctx) {
      const drawer = document.getElementById('nodeDrawer');
      drawer.classList.add('open');
      drawer.setAttribute('aria-hidden', 'false');
      activeNodeContext = ctx;
      document.getElementById('drawerTitle').textContent = normalizeLabel(ctx.label) || 'Node details';
      document.getElementById('drawerSub').textContent = 'Loading realtime node telemetry...';
      document.getElementById('drawerBody').innerHTML = '<div class="muted">Loading...</div>';
      await refreshActiveNodeInDrawer();
    }

    async function refreshActiveNodeInDrawer() {
      if (!activeNodeContext) return;
      const label = normalizeLabel(activeNodeContext.label);
      const serviceName = findServiceNameByLabel(label);
      const drawerSub = document.getElementById('drawerSub');
      const drawerBody = document.getElementById('drawerBody');
      try {
        if (!serviceName) {
          drawerSub.textContent = 'No mapped service for this node.';
          drawerBody.innerHTML = `
            <div class="kv">
              <div class="k">Label</div><div>${label || '-'}</div>
              <div class="k">View</div><div>${currentView}</div>
            </div>
            <div class="muted">Tip: service_map this view does not include this node.</div>
          `;
          return;
        }
        const data = await fetchNodeDetail(serviceName);
        const svc = data.service || {};
        const history = data.history || [];
        const m = data.metrics || {};
        drawerSub.textContent = `service: ${serviceName} • updated ${svc.checked_at || data.updated_at || '-'}`;
        drawerBody.innerHTML = `
          <div class="kv">
            <div class="k">Status</div><div>${statusBadge(svc.status)}</div>
            <div class="k">Latency</div><div>${formatMs(svc.latency_ms)}</div>
            <div class="k">HTTP</div><div>${svc.code == null ? '-' : svc.code}</div>
            <div class="k">Error Rate</div><div>${(m.error_rate_pct ?? 0).toFixed(2)}%</div>
            <div class="k">Transitions</div><div>${m.status_transitions ?? 0}</div>
            <div class="k">P95/P99</div><div>${formatMs(m.p95_latency_ms)} / ${formatMs(m.p99_latency_ms)}</div>
            <div class="k">SLO</div><div>${(m.availability_pct ?? 0).toFixed(2)}% vs ${(m.slo_target_pct ?? 99.5)}%</div>
            <div class="k">Endpoint</div><div style="word-break:break-word;">${svc.url || '-'}</div>
          </div>
          <strong style="font-size:13px;">Live timeline (multi-metric)</strong>
          <div style="margin-top:8px;">${renderMultiMetricTimeline(history)}</div>
          <div class="drawerActions">
            ${activeNodeContext.target ? `<a href="${activeNodeContext.target}" ${activeNodeContext.target.startsWith('/') ? '' : 'target="_blank" rel="noopener"'}>Open linked topology</a>` : ''}
            <a href="/node/${encodeURIComponent(serviceName)}" target="_blank">Open full drill-down</a>
            ${svc.url ? `<a href="${svc.url}" target="_blank" rel="noopener">Open health URL</a>` : ''}
          </div>
        `;
      } catch (e) {
        drawerSub.textContent = serviceName ? `service: ${serviceName}` : 'service mapping failed';
        drawerBody.innerHTML = `<div class="muted">Failed to load node detail: ${e.message}</div>`;
      }
    }

    async function refreshImpact(svg) {
      try {
        const r = await fetch('/api/topology/impact');
        const d = await r.json();
        lastImpact = d;
        document.getElementById('impactPanel').textContent = JSON.stringify(d, null, 2);
        if (svg) applyImpactHeatmap(svg);
      } catch (e) {
        document.getElementById('impactPanel').textContent = `impact fetch failed: ${e.message}`;
      }
    }

    function renderReplayList(svg) {
      const root = document.getElementById('replayList');
      root.innerHTML = '';
      replayData.slice().reverse().forEach((evt) => {
        const item = document.createElement('div');
        item.className = `replayItem ${selectedReplayEventId === evt.event_id ? 'active' : ''}`;
        item.innerHTML = `
          <div style="font-weight:600; font-size:12px;">${evt.flow_name}</div>
          <div class="muted">qps ${Number(evt.qps).toFixed(2)} • latency ${formatMs(evt.latency_ms)} • ${evt.status}</div>
          <div class="muted">${evt.checked_at}</div>
        `;
        item.addEventListener('click', () => {
          selectedReplayEventId = evt.event_id;
          drawReplayPath(svg, evt);
          renderReplayList(svg);
        });
        root.appendChild(item);
      });
    }

    async function refreshReplay(svg) {
      try {
        const r = await fetch('/api/flows/replay?limit=40');
        const d = await r.json();
        replayData = d.recent_paths || [];
        document.getElementById('flowSummary').textContent = JSON.stringify(d.summary || {}, null, 2);
        applyFlowAnimation(svg);
        renderReplayList(svg);
        if (!selectedReplayEventId && replayData.length) {
          const latest = replayData[replayData.length - 1];
          selectedReplayEventId = latest.event_id;
          drawReplayPath(svg, latest);
          renderReplayList(svg);
        }
      } catch (e) {
        document.getElementById('flowSummary').textContent = `replay fetch failed: ${e.message}`;
      }
    }

    function autoReplayTick(svg) {
      if (!autoReplay || replayData.length === 0) return;
      replayIdx = (replayIdx + 1) % replayData.length;
      const evt = replayData[replayIdx];
      selectedReplayEventId = evt.event_id;
      drawReplayPath(svg, evt);
      renderReplayList(svg);
    }

    async function refreshSnapshotAndStatus(svg) {
      try {
        const r = await fetch('/api/status?force=true');
        const d = await r.json();
        latestStatus = d;
        document.getElementById('snapshot').textContent = JSON.stringify({
          overall: d.overall,
          summary: d.summary,
          checked_at: d.checked_at
        }, null, 2);
        if (svg) applyRealtimeNodeStatus(svg, d);
        if (svg && impactMode) applyImpactHeatmap(svg);
        if (activeNodeContext) refreshActiveNodeInDrawer();
      } catch (e) {
        document.getElementById('snapshot').textContent = 'Failed: ' + e.message;
      }
    }

    function setupToggles(svg) {
      const impactBtn = document.getElementById('impactModeBtn');
      const replayBtn = document.getElementById('autoReplayBtn');
      impactBtn.addEventListener('click', () => {
        impactMode = !impactMode;
        impactBtn.textContent = `Impact Mode: ${impactMode ? 'ON' : 'OFF'}`;
        refreshSnapshotAndStatus(svg);
      });
      replayBtn.addEventListener('click', () => {
        autoReplay = !autoReplay;
        replayBtn.textContent = `Auto Replay: ${autoReplay ? 'ON' : 'OFF'}`;
      });
    }

    window.addEventListener('load', () => {
      setTimeout(async () => {
        const svg = document.querySelector('.mermaid svg');
        setupPanZoomAndExports(svg);
        if (svg) applyNodeLinks(svg);
        setupToggles(svg);
        document.getElementById('closeDrawerBtn').addEventListener('click', closeNodeDrawer);

        await refreshSnapshotAndStatus(svg);
        await refreshImpact(svg);
        await refreshReplay(svg);

        setInterval(() => refreshSnapshotAndStatus(svg), 10000);
        setInterval(() => refreshImpact(svg), 15000);
        setInterval(() => refreshReplay(svg), 12000);
        setInterval(() => autoReplayTick(svg), 3500);
      }, 350);
    });
  </script>
</body>
</html>

